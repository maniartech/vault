/**
 * Comprehensive Events System Test Suite
 *
 * This test suite ensures the vault events system is robust and reliable.
 * It covers all possible scenarios, edge cases, and error conditions to
 * guarantee the events system will never fail in production.
 */

import Vault from '../dist/vault.js';

describe('Vault Events System - Comprehensive Test Suite', () => {
  let vault;

  beforeEach(async () => {
    // Create a fresh vault instance for each test
    vault = new Vault(`test-events-${Date.now()}-${Math.random()}`);

    // Clean up any existing data
    await vault.clear();
  });

  afterEach(async () => {
    // Clean up after each test
    if (vault) {
      try {
        await vault.clear();
      } catch (e) {
        // Ignore cleanup errors
      }
    }
  });

  // ===== BASIC EVENT EMISSION TESTS =====

  describe('Basic Event Emission', () => {
    it('should emit "change" event on setItem operation', async () => {
      let eventReceived = false;
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventReceived = true;
        eventData = event.detail;
      });

      await vault.setItem('test-key', 'test-value', { ttl: 3600 });

      expect(eventReceived).toBe(true);
      expect(eventData).toEqual(jasmine.objectContaining({
        op: 'set',
        key: 'test-key',
        meta: { ttl: 3600 }
      }));
      expect(eventData.version).toEqual(jasmine.any(Number));
      expect(eventData.version).toBeCloseTo(Date.now(), -2);
    });

    it('should emit "change" event on removeItem operation', async () => {
      // Setup: Add an item first
      await vault.setItem('remove-key', 'remove-value', { custom: 'data' });

      let eventReceived = false;
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventReceived = true;
        eventData = event.detail;
      });

      await vault.removeItem('remove-key');

      expect(eventReceived).toBe(true);
      expect(eventData).toEqual(jasmine.objectContaining({
        op: 'remove',
        key: 'remove-key',
        meta: { custom: 'data' }
      }));
      expect(eventData.version).toEqual(jasmine.any(Number));
      expect(eventData.version).toBeCloseTo(Date.now(), -2);
    });

    it('should emit "change" event on clear operation', async () => {
      // Setup: Add some items first
      await vault.setItem('key1', 'value1');
      await vault.setItem('key2', 'value2');

      let eventReceived = false;
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventReceived = true;
        eventData = event.detail;
      });

      await vault.clear();

      expect(eventReceived).toBe(true);
      expect(eventData).toEqual(jasmine.objectContaining({
        op: 'clear'
      }));
      expect(eventData.key).toBeUndefined();
      expect(eventData.meta).toBeUndefined();
      expect(eventData.version).toEqual(jasmine.any(Number));
      expect(eventData.version).toBeCloseTo(Date.now(), -2);
    });

    it('should not emit events for getItem operations', async () => {
      await vault.setItem('get-key', 'get-value');

      let eventReceived = false;
      vault.addEventListener('change', () => {
        eventReceived = true;
      });

      await vault.getItem('get-key');
      await vault.getItem('non-existent-key');

      expect(eventReceived).toBe(false);
    });

    it('should not emit events for keys(), length(), or getItemMeta operations', async () => {
      await vault.setItem('meta-key', 'meta-value', { test: 'meta' });

      let eventReceived = false;
      vault.addEventListener('change', () => {
        eventReceived = true;
      });

      await vault.keys();
      await vault.length();
      await vault.getItemMeta('meta-key');

      expect(eventReceived).toBe(false);
    });
  });

  // ===== EVENT LISTENER MANAGEMENT TESTS =====

  describe('Event Listener Management', () => {
    it('should correctly add and trigger multiple event listeners', async () => {
      let listener1Called = false;
      let listener2Called = false;
      let listener3Called = false;

      const listener1 = () => { listener1Called = true; };
      const listener2 = () => { listener2Called = true; };
      const listener3 = () => { listener3Called = true; };

      vault.addEventListener('change', listener1);
      vault.addEventListener('change', listener2);
      vault.addEventListener('change', listener3);

      await vault.setItem('multi-listener-key', 'value');

      expect(listener1Called).toBe(true);
      expect(listener2Called).toBe(true);
      expect(listener3Called).toBe(true);
    });

    it('should correctly remove specific event listeners', async () => {
      let listener1Called = false;
      let listener2Called = false;

      const listener1 = () => { listener1Called = true; };
      const listener2 = () => { listener2Called = true; };

      vault.addEventListener('change', listener1);
      vault.addEventListener('change', listener2);

      // Remove only listener1
      vault.removeEventListener('change', listener1);

      await vault.setItem('remove-listener-key', 'value');

      expect(listener1Called).toBe(false);
      expect(listener2Called).toBe(true);
    });

    it('should handle removing non-existent listeners gracefully', () => {
      const nonExistentListener = () => {};

      // Should not throw when removing a listener that was never added
      expect(() => {
        vault.removeEventListener('change', nonExistentListener);
      }).not.throw();

      // Should not throw when removing from non-existent event type
      expect(() => {
        vault.removeEventListener('non-existent-event', nonExistentListener);
      }).not.throw();
    });

    it('should support event listener options (once, passive, etc.)', async () => {
      let callCount = 0;

      const listener = () => { callCount++; };

      // Add listener with 'once' option
      vault.addEventListener('change', listener, { once: true });

      await vault.setItem('once-key1', 'value1');
      await vault.setItem('once-key2', 'value2');

      expect(callCount).toEqual(1);
    });

    it('should handle addEventListener with different option formats', async () => {
      let booleanOptionCalled = false;
      let objectOptionCalled = false;

      const listener1 = () => { booleanOptionCalled = true; };
      const listener2 = () => { objectOptionCalled = true; };

      // Test boolean option format
      vault.addEventListener('change', listener1, true);

      // Test object option format
      vault.addEventListener('change', listener2, { passive: true });

      await vault.setItem('options-key', 'value');

      expect(booleanOptionCalled).toBe(true);
      expect(objectOptionCalled).toBe(true);
    });
  });

  // ===== ONCHANGE PROPERTY HANDLER TESTS =====

  describe('onchange Property Handler', () => {
    it('should call onchange handler when events are emitted', async () => {
      let onchangeCalled = false;
      let onchangeData = null;

      vault.onchange = (event) => {
        onchangeCalled = true;
        onchangeData = event.detail;
      };

      await vault.setItem('onchange-key', 'onchange-value');

      expect(onchangeCalled).toBe(true);
      expect(onchangeData).toEqual(jasmine.objectContaining({
        op: 'set',
        key: 'onchange-key'
      });
    });

    it('should handle errors in onchange handler gracefully', async () => {
      vault.onchange = () => {
        throw new Error('Intentional error in onchange');
      };

      // Should not throw or prevent normal operation
      await expectAsync(vault.setItem('error-key', 'error-value')).not.toBeRejected();

      // Verify the item was still stored despite the onchange error
      const value = await vault.getItem('error-key');
      expect(value).toEqual('error-value');
    });

    it('should work alongside regular event listeners', async () => {
      let onchangeCalled = false;
      let listenerCalled = false;

      vault.onchange = () => { onchangeCalled = true; };
      vault.addEventListener('change', () => { listenerCalled = true; });

      await vault.setItem('both-key', 'both-value');

      expect(onchangeCalled).toBe(true);
      expect(listenerCalled).toBe(true);
    });

    it('should allow onchange to be reassigned', async () => {
      let handler1Called = false;
      let handler2Called = false;

      vault.onchange = () => { handler1Called = true; };
      await vault.setItem('first-key', 'first-value');

      vault.onchange = () => { handler2Called = true; };
      await vault.setItem('second-key', 'second-value');

      expect(handler1Called).toBe(true);
      expect(handler2Called).toBe(true);
    });

    it('should handle onchange being set to null or undefined', async () => {
      vault.onchange = () => { throw new Error('Should not be called'); };
      vault.onchange = null;

      // Should not throw
      await expectAsync(vault.setItem('null-onchange', 'value')).not.toBeRejected();

      vault.onchange = undefined;
      await expectAsync(vault.setItem('undefined-onchange', 'value')).not.toBeRejected();
    });
  });

  // ===== CUSTOM EVENT DISPATCH TESTS =====

  describe('Custom Event Dispatch', () => {
    it('should allow manual event dispatching', () => {
      let eventReceived = false;
      let eventData = null;

      vault.addEventListener('custom-event', (event) => {
        eventReceived = true;
        eventData = event;
      });

      const customEvent = new CustomEvent('custom-event', {
        detail: { custom: 'data' }
      });

      const result = vault.dispatchEvent(customEvent);

      expect(result).toBe(true);
      expect(eventReceived).toBe(true);
      expect(eventData.detail).toEqual({ custom: 'data' });
    });

    it('should return false when dispatching prevented events', () => {
      vault.addEventListener('preventable-event', (event) => {
        event.preventDefault();
      });

      const event = new Event('preventable-event', { cancelable: true });
      const result = vault.dispatchEvent(event);

      expect(result).toBe(false);
    });

    it('should handle dispatching events with no listeners', () => {
      const event = new CustomEvent('no-listeners');

      expect(() => {
        const result = vault.dispatchEvent(event);
        expect(result).toBe(true);
      }).not.throw();
    });
  });

  // ===== EVENT TIMING AND ORDERING TESTS =====

  describe('Event Timing and Ordering', () => {
    it('should emit events after operations complete successfully', async () => {
      let eventEmitted = false;
      let operationCompleted = false;

      vault.addEventListener('change', () => {
        eventEmitted = true;
        // Event should fire after operation completes
        expect(operationCompleted).toBe(true);
      });

      await vault.setItem('timing-key', 'timing-value');
      operationCompleted = true;

      expect(eventEmitted).toBe(true);
    });

    it('should not emit events if operations fail', async () => {
      let eventEmitted = false;

      vault.addEventListener('change', () => {
        eventEmitted = true;
      });

      // Test with invalid key (should cause validation error)
      try {
        await vault.setItem('', 'empty-key-value');
      } catch (e) {
        // Expected to fail
      }

      try {
        await vault.setItem(null, 'null-key-value');
      } catch (e) {
        // Expected to fail
      }

      expect(eventEmitted).toBe(false);
    });

    it('should maintain proper event order for sequential operations', async () => {
      const eventOrder = [];

      vault.addEventListener('change', (event) => {
        eventOrder.push(`${event.detail.op}-${event.detail.key || 'clear'}`);
      });

      await vault.setItem('key1', 'value1');
      await vault.setItem('key2', 'value2');
      await vault.removeItem('key1');
      await vault.clear();

      expect(eventOrder).toEqual([
        'set-key1',
        'set-key2',
        'remove-key1',
        'clear-clear'
      ]);
    });

    it('should handle rapid sequential operations correctly', async () => {
      const events = [];

      vault.addEventListener('change', (event) => {
        events.push({
          op: event.detail.op,
          key: event.detail.key,
          timestamp: Date.now()
        });
      });

      // Perform rapid operations
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(vault.setItem(`rapid-key-${i}`, `rapid-value-${i}`));
      }

      await Promise.all(promises);

      expect(events).toHaveLength(10);
      expect(events.every(e => e.op === 'set')).toBe(true);
      expect(events.map(e => e.key)).to.include.members([
        'rapid-key-0', 'rapid-key-1', 'rapid-key-2', 'rapid-key-3', 'rapid-key-4',
        'rapid-key-5', 'rapid-key-6', 'rapid-key-7', 'rapid-key-8', 'rapid-key-9'
      ]);
    });
  });

  // ===== EVENT DATA INTEGRITY TESTS =====

  describe('Event Data Integrity', () => {
    it('should include correct metadata in set operation events', async () => {
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventData = event.detail;
      });

      const metadata = { ttl: 3600, priority: 'high', custom: { nested: 'data' } };
      await vault.setItem('meta-key', 'meta-value', metadata);

      expect(eventData.meta).toEqual(metadata);
      expect(eventData.op).toEqual('set');
      expect(eventData.key).toEqual('meta-key');
      expect(eventData.version).toEqual(jasmine.any(Number));
    });

    it('should include correct metadata in remove operation events', async () => {
      const metadata = { original: 'metadata' };
      await vault.setItem('remove-meta-key', 'remove-meta-value', metadata);

      let eventData = null;
      vault.addEventListener('change', (event) => {
        eventData = event.detail;
      });

      await vault.removeItem('remove-meta-key');

      expect(eventData.meta).toEqual(metadata);
      expect(eventData.op).toEqual('remove');
      expect(eventData.key).toEqual('remove-meta-key');
    });

    it('should handle null metadata correctly', async () => {
      let setEventData = null;
      let removeEventData = null;

      const events = [];
      vault.addEventListener('change', (event) => {
        events.push(event.detail);
      });

      await vault.setItem('null-meta-key', 'null-meta-value', null);
      await vault.removeItem('null-meta-key');

      expect(events[0].meta).toBeNull();
      expect(events[1].meta).toBeNull();
    });

    it('should handle undefined metadata correctly', async () => {
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventData = event.detail;
      });

      // Don't pass metadata parameter (should default to null)
      await vault.setItem('undefined-meta-key', 'undefined-meta-value');

      expect(eventData.meta).toBeNull();
    });

    it('should generate monotonically increasing version numbers', async () => {
      const versions = [];

      vault.addEventListener('change', (event) => {
        versions.push(event.detail.version);
      });

      await vault.setItem('v1', 'value1');
      // Small delay to ensure different timestamps
      await new Promise(resolve => setTimeout(resolve, 1));
      await vault.setItem('v2', 'value2');
      await new Promise(resolve => setTimeout(resolve, 1));
      await vault.setItem('v3', 'value3');

      expect(versions).toHaveLength(3);
      expect(versions[0]).to.be.lessThan(versions[1]);
      expect(versions[1]).to.be.lessThan(versions[2]);
    });
  });

  // ===== EDGE CASES AND ERROR SCENARIOS =====

  describe('Edge Cases and Error Scenarios', () => {
    it('should handle special characters in keys correctly', async () => {
      const specialKeys = [
        'key with spaces',
        'key-with-dashes',
        'key_with_underscores',
        'key.with.dots',
        'key/with/slashes',
        'key\\with\\backslashes',
        'key@with#special$chars%',
        'keyðŸš€withðŸ’¯emojis'
      ];

      const events = [];
      vault.addEventListener('change', (event) => {
        events.push(event.detail.key);
      });

      for (const key of specialKeys) {
        await vault.setItem(key, `value-for-${key}`);
      }

      expect(events.map(e => e.key)).toEqual(specialKeys);
    });

    it('should handle very large metadata objects', async () => {
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventData = event.detail;
      });

      const largeMeta = {
        array: new Array(1000).fill('data'),
        object: {},
        nested: { deep: { very: { deep: { structure: 'value' } } } }
      };

      // Fill the object with many properties
      for (let i = 0; i < 100; i++) {
        largeMeta.object[`prop${i}`] = `value${i}`;
      }

      await vault.setItem('large-meta-key', 'large-meta-value', largeMeta);

      expect(eventData.meta).toEqual(largeMeta);
    });

    it('should handle concurrent operations with events', async () => {
      const events = [];

      vault.addEventListener('change', (event) => {
        events.push({
          op: event.detail.op,
          key: event.detail.key,
          timestamp: Date.now()
        });
      });

      // Perform many concurrent operations
      const operations = [];
      for (let i = 0; i < 20; i++) {
        operations.push(vault.setItem(`concurrent-${i}`, `value-${i}`));
      }

      await Promise.all(operations);

      expect(events).toHaveLength(20);

      // All events should be set operations
      expect(events.every(e => e.op === 'set')).toBe(true);

      // All keys should be present
      const keys = events.map(e => e.key).sort();
      const expectedKeys = Array.from({length: 20}, (_, i) => `concurrent-${i}`).sort();
      expect(keys).toEqual(expectedKeys);
    });

    it('should handle listener removal during event processing', async () => {
      let firstListenerCalls = 0;
      let secondListenerCalls = 0;

      const firstListener = () => {
        firstListenerCalls++;
        // Remove self during processing
        vault.removeEventListener('change', firstListener);
      };

      const secondListener = () => {
        secondListenerCalls++;
      };

      vault.addEventListener('change', firstListener);
      vault.addEventListener('change', secondListener);

      await vault.setItem('self-remove-1', 'value1');
      await vault.setItem('self-remove-2', 'value2');

      expect(firstListenerCalls).toEqual(1);
      expect(secondListenerCalls).toEqual(2);
    });

    it('should handle adding listeners during event processing', async () => {
      let originalListenerCalls = 0;
      let addedListenerCalls = 0;

      const addedListener = () => {
        addedListenerCalls++;
      };

      const originalListener = () => {
        originalListenerCalls++;
        if (originalListenerCalls === 1) {
          // Add a new listener during processing
          vault.addEventListener('change', addedListener);
        }
      };

      vault.addEventListener('change', originalListener);

      await vault.setItem('add-during-1', 'value1');
      await vault.setItem('add-during-2', 'value2');

      expect(originalListenerCalls).toEqual(2);
      expect(addedListenerCalls).toEqual(1); // Should only be called for the second event
    });

    it('should maintain event system integrity after database errors', async () => {
      let eventReceived = false;

      vault.addEventListener('change', () => {
        eventReceived = true;
      });

      // Force a database error by closing the database manually
      if (vault.db) {
        vault.db.close();
        vault.db = null;
      }

      // The next operation should fail but not break the event system
      try {
        await vault.setItem('error-key', 'error-value');
      } catch (e) {
        // Expected to fail
      }

      // Event should not have been emitted for failed operation
      expect(eventReceived).toBe(false);

      // But the event system should still work for subsequent operations
      await vault.setItem('recovery-key', 'recovery-value');
      expect(eventReceived).toBe(true);
    });

    it('should handle memory pressure scenarios', async () => {
      const events = [];

      vault.addEventListener('change', (event) => {
        events.push({
          key: event.detail.key,
          version: event.detail.version
        });
      });

      // Perform a large number of operations to test memory handling
      for (let i = 0; i < 1000; i++) {
        await vault.setItem(`memory-test-${i}`, `value-${i}`);
      }

      expect(events).toHaveLength(1000);

      // Verify that all events have proper structure
      expect(events.every(e => typeof e.key === 'string' && typeof e.version === 'number')).toBe(true);
    });
  });

  // ===== MIDDLEWARE INTEGRATION TESTS =====

  describe('Middleware Integration with Events', () => {
    it('should emit events after middleware processing', async () => {
      let eventData = null;
      let middlewareProcessed = false;

      // Add middleware that modifies metadata
      vault.use({
        before: (context) => {
          if (context.operation === 'set') {
            context.meta = {
              ...context.meta,
              processed: true,
              timestamp: Date.now()
            };
          }
          return context;
        },
        after: (context, result) => {
          middlewareProcessed = true;
          return result;
        }
      });

      vault.addEventListener('change', (event) => {
        eventData = event.detail;
      });

      await vault.setItem('middleware-key', 'middleware-value', { original: 'meta' });

      expect(middlewareProcessed).toBe(true);
      expect(eventData.meta).to.include({
        original: 'meta',
        processed: true
      });
      expect(eventData.meta.timestamp).toEqual(jasmine.any(Number));
    });

    it('should not emit events when middleware prevents operations', async () => {
      let eventEmitted = false;

      // Add middleware that blocks certain operations
      vault.use({
        before: (context) => {
          if (context.key === 'blocked-key') {
            throw new Error('Operation blocked by middleware');
          }
          return context;
        }
      });

      vault.addEventListener('change', () => {
        eventEmitted = true;
      });

      // This should succeed and emit an event
      await vault.setItem('allowed-key', 'allowed-value');
      expect(eventEmitted).toBe(true);

      // Reset flag
      eventEmitted = false;

      // This should fail and not emit an event
      try {
        await vault.setItem('blocked-key', 'blocked-value');
      } catch (e) {
        // Expected to fail
      }

      expect(eventEmitted).toBe(false);
    });

    it('should handle events with expiration middleware', async () => {
      // This test assumes expiration middleware is available
      // If not, it will be skipped
      try {
        const { expiration } = await import('../src/middlewares/expiration.js');

        vault.use(expiration);

        let eventData = null;
        vault.addEventListener('change', (event) => {
          eventData = event.detail;
        });

        // Set item with TTL
        await vault.setItem('ttl-key', 'ttl-value', { ttl: 1 }); // 1 second TTL

        expect(eventData).not.toBeNull();
        expect(eventData.op).toEqual('set');
        expect(eventData.key).toEqual('ttl-key');
        expect(eventData.meta.ttl).toEqual(1);

      } catch (importError) {
        // Skip this test if expiration middleware is not available
        console.log('Skipping expiration middleware test - module not available');
      }
    });
  });

  // ===== PERFORMANCE AND STRESS TESTS =====

  describe('Performance and Stress Tests', () => {
    it('should handle high-frequency events efficiently', async function() {
      this.timeout(10000); // Allow more time for this test

      let eventCount = 0;
      const startTime = Date.now();

      vault.addEventListener('change', () => {
        eventCount++;
      });

      // Perform many rapid operations
      const operations = [];
      for (let i = 0; i < 500; i++) {
        operations.push(vault.setItem(`perf-${i}`, `value-${i}`));
      }

      await Promise.all(operations);

      const endTime = Date.now();
      const duration = endTime - startTime;

      expect(eventCount).toEqual(500);
      expect(duration).to.be.lessThan(5000); // Should complete within 5 seconds
    });

    it('should handle many listeners efficiently', async () => {
      const listenerCount = 100;
      const callCounts = new Array(listenerCount).fill(0);

      // Add many listeners
      for (let i = 0; i < listenerCount; i++) {
        vault.addEventListener('change', (() => {
          const index = i;
          return () => {
            callCounts[index]++;
          };
        })());
      }

      await vault.setItem('many-listeners-key', 'many-listeners-value');

      // All listeners should have been called once
      expect(callCounts.every(count => count === 1)).toBe(true);
    });

    it('should not cause memory leaks with repeated listener add/remove', async () => {
      const operations = 100;

      for (let i = 0; i < operations; i++) {
        const listener = () => {};
        vault.addEventListener('change', listener);
        vault.removeEventListener('change', listener);
      }

      // Add one final listener to test that the event system still works
      let finalEventReceived = false;
      vault.addEventListener('change', () => {
        finalEventReceived = true;
      });

      await vault.setItem('memory-leak-test', 'value');

      expect(finalEventReceived).toBe(true);
    });
  });

  // ===== BROWSER COMPATIBILITY TESTS =====

  describe('Browser Compatibility', () => {
    it('should work with different event listener object formats', async () => {
      let objectListenerCalled = false;
      let functionListenerCalled = false;

      // Function listener
      const functionListener = () => {
        functionListenerCalled = true;
      };

      // Object listener
      const objectListener = {
        handleEvent: () => {
          objectListenerCalled = true;
        }
      };

      vault.addEventListener('change', functionListener);
      vault.addEventListener('change', objectListener);

      await vault.setItem('compat-key', 'compat-value');

      expect(functionListenerCalled).toBe(true);
      expect(objectListenerCalled).toBe(true);
    });

    it('should handle CustomEvent polyfill scenarios', async () => {
      // This test ensures our events work even with older CustomEvent implementations
      let eventReceived = false;
      let eventDetail = null;

      vault.addEventListener('change', (event) => {
        eventReceived = true;
        eventDetail = event.detail;
      });

      await vault.setItem('polyfill-key', 'polyfill-value');

      expect(eventReceived).toBe(true);
      expect(eventDetail).to.be.an('object');
      expect(eventDetail.op).toEqual('set');
    });
  });

  // ===== SECURITY TESTS =====

  describe('Security Considerations', () => {
    it('should not expose internal vault state through events', async () => {
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventData = event.detail;
      });

      await vault.setItem('security-key', 'security-value');

      // Event should not contain references to internal vault objects
      expect(eventData).not.toHaveProperty('vaultInstance');
      expect(eventData).not.toHaveProperty('db');
      expect(eventData).not.toHaveProperty('__bus');
    });

    it('should prevent event detail modification affecting vault state', async () => {
      let eventData = null;

      vault.addEventListener('change', (event) => {
        eventData = event.detail;
        // Attempt to modify event data
        event.detail.op = 'modified';
        event.detail.key = 'modified-key';
        event.detail.meta = { modified: true };
      });

      await vault.setItem('immutable-key', 'immutable-value', { original: true });

      // Verify the stored data wasn't affected by event modification
      const storedValue = await vault.getItem('immutable-key');
      const storedMeta = await vault.getItemMeta('immutable-key');

      expect(storedValue).toEqual('immutable-value');
      expect(storedMeta).toEqual({ original: true });
    });
  });
});